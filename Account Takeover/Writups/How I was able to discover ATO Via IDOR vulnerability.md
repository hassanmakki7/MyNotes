
![](https://miro.medium.com/v2/resize:fit:700/0*Fq-PmjWQn4tBIoTE.png)

Hello everyoneÂ ,  
Iâ€™m Ahmed Tarek, Today I would like to share with you a crazy and weird IDOR discovery in HackerOne â€™s program, This is my 1st article so if there is any mistakesÂ , leave on it or DM me on facebook. Without wasting any time we will start on article.**So letâ€™s get started! ðŸ˜‰**

![](https://miro.medium.com/v2/resize:fit:330/1*yxXY4xrfMkDdDXHR9fqImQ.jpeg)

letâ€™s dive in

_Letâ€™s consider the target as_ `_target.com_` _. I quickly signed up with necessary information and created & Verified both accounts for testing purpose_ `_Account 1 & Account 2_` _in the same time._

When I tried accessing the profile from both accounts, I noticed something kinda fishy. The application sends a request to an endpoint called `/api/v1/user/profile` to view the profile. Let's dissect the request, shall we?

For `_Account 1_`, the request looks like this:

GET /api/v1/user/profile?  
user_id=273948261&auth_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWI  
iOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxw  
RJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c&timestamp=1349328731

Now, pay close attention to the `user_id`: `273948261`. It's crucial, and here's why. When we peek at `_Account 2_` request:

GET /api/v1/user/profile?  
user_id=273948262&auth_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ  
zdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkF0dGVudG9yIiwiaWF0IjoxNjQ5MjQwNjcwL  
CJleHAiOjE2NDkyNDExNzB9&timestamp=1349328732

Notice the subtle difference? The user ID in `_Account 2_` request is just one step ahead of the `user_id` in `_Account 2_`, so thats if we sign in with another account it will get an `user_id` increased by one from `_Account 2 ._`Sneaky, right? but wait, it gets better.

Now, hereâ€™s the catch. The application is supposed to validate the user through three things: `user_id`, `auth_token`, and `timestamp`. But does it really do that?

![](https://miro.medium.com/v2/resize:fit:225/1*Bt2vu3lpEpxV27YkxT7agw.jpeg)

I tried changing the `user_`id and the auth_token( the auth_t) from the attacker to the userÂ , but it gave me a bad request. So, it seems like itâ€™s validating the token, right? Wrong.

Upon further investigation, I realized that the application doesnâ€™t validate the tokenâ€™s validity based on the token itself. Instead, it validates it based on the `timestamp` so if the`timestamp` is right, and even if the token is wrong but it will accept the request.

![](https://miro.medium.com/v2/resize:fit:225/1*QjBPuwvjltQmag7Ew42nlw.jpeg)

i know

lets explain it more

once a token is generated, it remains valid for 60 seconds from the time it was create, if the token is used after this 60-second period, it is considered expired and be invalid.

in our application, the timestamp increments by 1 every 10 seconds. After 60 seconds, it deems the token invalid. So, if the `timestamp` was `1349328731`, and a request sent 10 seconds later it will increase by 1 and the `timestamp` will be `1349328732` and would be accepted. But after 60 seconds, it will increase by 6 and will be`1349328737`, and it would be considered an invalid token, because the Token Validity Window will be expired.

So how do i expliot it ?

![](https://miro.medium.com/v2/resize:fit:400/1*O6GFagx9tzbefjr6lKRL7Q.gif)

I changed the `user_id` from the `_Account 2_`to the `_Account 1_` to try to access `_Account 2_` and matched the timestamp value in it to`_Account 1_` timestamp, which was `1349328731` it didn't accept it, but when I bumped the `_Account 2_`timestamp to `1349328733` which in the same Validity Window (still the 60 second didnt finshed), it went through smoothly. Can't pinpoint the exact reason, but hey, it worked!, and now i can takeover any account by just changing the `user_id.`

In the end, the company acknowledged the issue as a critical severity and got paid $$$.

Thanks for reading!

